<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>The Hawk Games — Plinko (Physics MVP)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="On-brand Plinko with physics-like drops, weighted bias, and live RTP.">
  <style>
    :root{--bg:#121212;--fg:#f5f5f5;--muted:#bfbfbf;--gold:#e0a94a;--card:#1b1b1b;--border:#2a2a2a;}
    *{box-sizing:border-box}
    html,body{margin:0;padding:0}
    body{background:var(--bg);color:var(--fg);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    .header{display:flex;align-items:center;justify-content:space-between;padding:12px 20px;border-bottom:1px solid var(--border);background:#0e0e0e}
    .brand{color:var(--gold);text-decoration:none;font-weight:700}
    .container{max-width:1180px;margin:24px auto;padding:0 16px;display:grid;grid-template-columns:1fr 360px;gap:20px}
    .panel{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:14px}
    h1,h2,h3{margin:8px 0}
    .muted{color:var(--muted)}
    .controls{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
    .btn{background:#222;color:var(--fg);padding:10px 14px;border:1px solid var(--border);border-radius:10px;cursor:pointer}
    .btn:hover{border-color:var(--gold)}
    .btn-primary{background:var(--gold);color:#1a1a1a;border:none}
    .btn-primary:hover{filter:brightness(1.05)}
    .pill{display:inline-block;padding:4px 8px;border:1px solid var(--border);border-radius:999px;color:var(--muted);font-size:12px}
    .board-wrap{position:relative;min-height:660px;display:flex;align-items:center;justify-content:center}
    svg{width:100%;height:auto;max-height:880px;display:block}
    .stat{display:flex;align-items:center;justify-content:space-between;padding:8px;border:1px dashed var(--border);border-radius:10px;margin-top:8px}
    .toast{position:fixed;left:50%;bottom:24px;transform:translateX(-50%);background:#1b1b1b;border:1px solid var(--border);color:var(--fg);padding:10px 14px;border-radius:10px;box-shadow:0 6px 30px rgba(0,0,0,.4);opacity:0;pointer-events:none;transition:opacity .25s, transform .25s}
    .toast.show{opacity:1;transform:translateX(-50%) translateY(-4px)}
    .grid{display:grid;gap:8px}
    .grid.cols-2{grid-template-columns:1fr 1fr}
    .payout-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:6px;margin-top:10px}
    .payout-card{background:#161616;border:1px solid var(--border);border-radius:10px;padding:8px;text-align:center}
    .payout-card .idx{font-size:12px;color:var(--muted)}
    .payout-card .val{font-weight:700;color:var(--gold)}
    .hr{height:1px;background:linear-gradient(90deg,transparent, var(--border), transparent);margin:12px 0}
    .form-row{display:flex;gap:6px;align-items:center}
    .form-row label{font-size:12px;color:var(--muted);width:94px}
    input[type="number"], input[type="range"], select{
      width:100%;background:#101010;border:1px solid var(--border);color:var(--fg);border-radius:8px;padding:8px
    }
    input[type="range"]{height:34px}
    .mode-note{font-size:12px;color:var(--muted);margin-top:-6px}
    @media (max-width:1000px){ .container{grid-template-columns:1fr} }
  </style>
</head>
<body>
  <header class="header">
    <a class="brand" href="#">The Hawk Games</a>
    <div class="pill">Plinko — Physics/Weighted</div>
  </header>

  <main class="container">
    <section class="panel">
      <h1>Plinko (on-brand, physics-like)</h1>
      <p class="muted">Client shows physics; **server should decide outcomes** in production. Modes: unbiased, weighted, or server-guided.</p>
      <div class="board-wrap">
        <svg id="plinko" viewBox="0 0 900 980" aria-label="Plinko Board"></svg>
      </div>
      <div class="controls">
        <button id="drop1" class="btn btn-primary">Drop 1</button>
        <button id="drop3" class="btn">Drop 3×</button>
        <button id="reset" class="btn">Reset</button>
        <span class="pill" id="rowsPill"></span>
        <span class="pill" id="rtpPill"></span>
      </div>
    </section>

    <aside class="panel">
      <h2>Physics & Odds</h2>
      <div class="grid cols-2">
        <div class="form-row"><label>Mode</label>
          <select id="mode">
            <option value="unbiased">Unbiased (p=0.5)</option>
            <option value="weighted">Weighted (choose p)</option>
            <option value="guided">Server-guided (target slot)</option>
          </select>
        </div>
        <div class="form-row"><label>Rows</label>
          <input id="rows" type="number" min="6" max="16" step="1" value="12">
        </div>

        <div class="form-row" id="pRow"><label>p (Right)</label>
          <input id="p" type="range" min="0" max="1" step="0.01" value="0.50">
        </div>
        <div class="form-row" id="targetRow" style="display:none;"><label>Target slot</label>
          <input id="target" type="number" min="0" step="1" value="6">
        </div>

        <div class="form-row"><label>Stake (£)</label>
          <input id="stake" type="number" min="0" step="0.01" value="1.00">
        </div>
        <div class="form-row"><label>Gravity</label>
          <input id="grav" type="range" min="800" max="5000" step="50" value="2600">
        </div>
      </div>
      <p class="mode-note" id="modeNote"></p>

      <div class="hr"></div>
      <h3>Payouts</h3>
      <div id="payoutGrid" class="payout-grid"></div>
      <div id="prizeForm" class="grid cols-2" style="margin-top:8px;"></div>

      <div class="hr"></div>
      <div class="stat"><span>Total Drops</span><strong id="statDrops">0</strong></div>
      <div class="stat"><span>Total Winnings</span><strong id="statWinnings">£0.00</strong></div>
      <div class="stat"><span>Session RTP</span><strong id="statSessionRTP">0%</strong></div>
    </aside>
  </main>

  <div id="toast" class="toast" role="status" aria-live="polite"></div>

  <script>
    // ------- Config / State -------
    const STATE = {
      rows: 12,
      stake: 1,
      payouts: [],      // length rows+1
      mode: 'unbiased', // 'unbiased' | 'weighted' | 'guided'
      p: 0.5,           // weighted probability of RIGHT
      targetSlot: 6,    // guided mode
      g: 2600,          // px/s^2 gravity
      pegR: 7.5,
      ballR: 10,
      margin: 70,
      rowGap: 62
    };

    // init payouts symmetric-ish with a juicy centre
    function defaultPayouts(rows){
      const mid = Math.floor(rows/2);
      const arr = Array(rows+1).fill(0);
      for (let k=0; k<=rows; k++){
        const d = Math.abs(k - mid);
        arr[k] = d===0 ? 25 : d===1 ? 5 : d===2 ? 2 : d===3 ? 1 : d===4 ? 0.5 : d===5 ? 0.25 : 0;
      }
      return arr;
    }
    STATE.payouts = defaultPayouts(STATE.rows);

    // ------- DOM -------
    const svg = document.getElementById('plinko');
    const rowsPill = document.getElementById('rowsPill');
    const rtpPill = document.getElementById('rtpPill');
    const drop1 = document.getElementById('drop1');
    const drop3 = document.getElementById('drop3');
    const resetBtn = document.getElementById('reset');
    const payoutGrid = document.getElementById('payoutGrid');
    const prizeForm = document.getElementById('prizeForm');
    const statDrops = document.getElementById('statDrops');
    const statWinnings = document.getElementById('statWinnings');
    const statSessionRTP = document.getElementById('statSessionRTP');
    const toast = document.getElementById('toast');

    const modeSel = document.getElementById('mode');
    const rowsInp = document.getElementById('rows');
    const pRow = document.getElementById('pRow');
    const targetRow = document.getElementById('targetRow');
    const pInp = document.getElementById('p');
    const targetInp = document.getElementById('target');
    const stakeInp = document.getElementById('stake');
    const gravInp = document.getElementById('grav');
    const modeNote = document.getElementById('modeNote');

    // ------- Geometry -------
    let GEO = null;
    function computeGeo(){
      const W=900,H=980,N=STATE.rows,m=STATE.margin;
      const usable=W-2*m;
      const colGap=usable/(N+1);
      const xSlot=(s)=> m + 0.5*colGap + s*colGap;
      const yRow=(r)=> m + STATE.rowGap*(r+1);
      const xPeg=(r,j)=> m + 0.5*colGap*(N - r + 1) + j*colGap;
      return {W,H,N,m,colGap,xSlot,yRow,xPeg, slotsY: m + STATE.rowGap*(N+1) + 12};
    }

    function buildBoard(){
      GEO = computeGeo();
      while(svg.firstChild) svg.removeChild(svg.firstChild);

      const bg = document.createElementNS('http://www.w3.org/2000/svg','rect');
      bg.setAttribute('x', GEO.m/2);
      bg.setAttribute('y', GEO.m/2);
      bg.setAttribute('width', GEO.W - GEO.m);
      bg.setAttribute('height', GEO.H - GEO.m);
      bg.setAttribute('fill', '#0e0e0e');
      bg.setAttribute('stroke', 'var(--border)');
      svg.appendChild(bg);

      for (let r=0;r<GEO.N;r++){
        for (let j=0;j<=r;j++){
          const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
          c.setAttribute('cx', GEO.xPeg(r,j));
          c.setAttribute('cy', GEO.yRow(r));
          c.setAttribute('r', STATE.pegR);
          c.setAttribute('fill','var(--gold)');
          c.setAttribute('opacity','0.9');
          svg.appendChild(c);
        }
      }

      for (let s=0;s<=GEO.N;s++){
        const x=GEO.xSlot(s), w=GEO.colGap*0.92;
        const rect=document.createElementNS('http://www.w3.org/2000/svg','rect');
        rect.setAttribute('x', x - w/2);
        rect.setAttribute('y', GEO.slotsY);
        rect.setAttribute('width', w); rect.setAttribute('height', 50);
        rect.setAttribute('rx','10');
        rect.setAttribute('fill','#161616'); rect.setAttribute('stroke','#2a2a2a');
        svg.appendChild(rect);

        const t1=document.createElementNS('http://www.w3.org/2000/svg','text');
        t1.setAttribute('x',x); t1.setAttribute('y', GEO.slotsY+20);
        t1.setAttribute('text-anchor','middle'); t1.setAttribute('fill','var(--muted)'); t1.setAttribute('font-size','12');
        t1.textContent=`Slot ${s}`; svg.appendChild(t1);

        const t2=document.createElementNS('http://www.w3.org/2000/svg','text');
        t2.setAttribute('x',x); t2.setAttribute('y', GEO.slotsY+38);
        t2.setAttribute('text-anchor','middle'); t2.setAttribute('fill','var(--gold)'); t2.setAttribute('font-size','12');
        t2.textContent=fmtGBP(STATE.payouts[s]||0); svg.appendChild(t2);
      }

      const top=document.createElementNS('http://www.w3.org/2000/svg','text');
      top.setAttribute('x', GEO.W/2); top.setAttribute('y', GEO.m+12);
      top.setAttribute('text-anchor','middle'); top.setAttribute('fill','var(--muted)'); top.setAttribute('font-size','12');
      top.textContent='Drop Zone'; svg.appendChild(top);
    }

    function updateSlotLabels(){
      const children=[...svg.childNodes];
      children.forEach(el=>{
        if(el.nodeName==='text'){
          const y=+el.getAttribute('y');
          if(Math.abs(y-(GEO.slotsY+38))<0.6){
            const x=+el.getAttribute('x');
            let best=0,dist=Infinity;
            for(let s=0;s<=GEO.N;s++){
              const d=Math.abs(x-GEO.xSlot(s));
              if(d<dist){dist=d;best=s;}
            }
            el.textContent=fmtGBP(STATE.payouts[best]||0);
          }
        }
      });
    }

    // ------- UI helpers -------
    const fmtGBP = (n)=> '£'+Number(n).toFixed(2);
    function showToast(text){
      toast.textContent=text; toast.classList.add('show');
      clearTimeout(showToast._t); showToast._t=setTimeout(()=>toast.classList.remove('show'),1700);
    }
    function nCr(n,r){ if(r<0||r>n)return 0; if(r===0||r===n)return 1; let res=1; for(let i=1;i<=r;i++) res=res*(n-r+i)/i; return res; }
    function rtp(p){
      const N=STATE.rows; const denom=Math.pow(2, N)*Math.pow(p/(1-p),0); // not used directly
      let exp=0;
      for(let k=0;k<=N;k++){
        const prob = ( (nCr(N,k)) * Math.pow(p,k) * Math.pow(1-p,N-k) );
        exp += prob * (STATE.payouts[k]||0);
      }
      return exp / Math.max(STATE.stake, 0.0001);
    }

    function renderPayoutGrid(){
      payoutGrid.innerHTML='';
      STATE.payouts.forEach((v,i)=>{
        const card=document.createElement('div'); card.className='payout-card';
        const a=document.createElement('div'); a.className='idx'; a.textContent=`Slot ${i}`;
        const b=document.createElement('div'); b.className='val'; b.textContent=fmtGBP(v);
        card.appendChild(a); card.appendChild(b); payoutGrid.appendChild(card);
      });
    }
    function renderPrizeForm(){
      prizeForm.innerHTML='';
      for(let s=0;s<=STATE.rows;s++){
        const row=document.createElement('div'); row.className='form-row';
        const lab=document.createElement('label'); lab.textContent=`Slot ${s}`;
        const inp=document.createElement('input'); inp.type='number'; inp.step='0.01'; inp.min='0'; inp.value=Number(STATE.payouts[s]||0).toFixed(2);
        inp.addEventListener('input',()=>{
          const v=parseFloat(inp.value||'0')||0; STATE.payouts[s]=v; updateSlotLabels(); renderPayoutGrid(); updateMeta();
        });
        row.appendChild(lab); row.appendChild(inp); prizeForm.appendChild(row);
      }
    }
    function updateMeta(){
      rowsPill.textContent=`Rows: ${STATE.rows} (slots ${STATE.rows+1})`;
      const p = STATE.mode==='weighted' ? STATE.p : 0.5;
      rtpPill.textContent=`RTP: ${(rtp(p)*100).toFixed(1)}%`;
    }

    // ------- Physics drop (weighted/guided) -------
    let dropping=false, queue=0, session={drops:0,winnings:0};

    function updateStats(){
      statDrops.textContent=session.drops;
      statWinnings.textContent=fmtGBP(session.winnings);
      const spent=session.drops*STATE.stake;
      statSessionRTP.textContent = spent>0 ? ((session.winnings/spent)*100).toFixed(1)+'%' : '0%';
    }

    function decideStep(rightsSoFar, rowsRemaining){
      if(STATE.mode==='guided'){
        const needRights = Math.max(0, STATE.targetSlot - rightsSoFar);
        // If we must still get more rights than rows left allow, force right, else probabilistic nudge
        if(needRights > rowsRemaining) return -1; // force left to stay feasible (edge)
        if(needRights === rowsRemaining) return 1; // must take right all the way
        // bias toward achieving the target smoothly
        const bias = 0.58; // subtle
        return Math.random() < bias ? 1 : -1;
      }
      if(STATE.mode==='weighted'){
        return Math.random() < STATE.p ? 1 : -1;
      }
      // unbiased
      return (crypto.getRandomValues(new Uint8Array(1))[0] & 1) ? 1 : -1;
    }

    async function drop(){
      if(dropping){ queue++; return; }
      dropping=true;
      try{
        // Ball state
        let x = GEO.xSlot(Math.floor(GEO.N/2));
        let y = STATE.margin + 10;
        let vx = 0, vy = 0;
        let nextRow = 0;
        let rights = 0;

        // If guided, clamp target inside [0,N]
        STATE.targetSlot = Math.max(0, Math.min(GEO.N, Math.round(STATE.targetSlot)));

        const ball=document.createElementNS('http://www.w3.org/2000/svg','circle');
        ball.setAttribute('cx', x); ball.setAttribute('cy', y); ball.setAttribute('r', STATE.ballR);
        ball.setAttribute('fill','var(--gold)'); ball.setAttribute('opacity','0.97');
        svg.appendChild(ball);

        let lastTs=null; const airDrag=0.0008; const wallPadding=STATE.margin*0.5;
        const leftBound = STATE.margin + STATE.ballR + wallPadding*0.2;
        const rightBound = GEO.W - STATE.margin - STATE.ballR - wallPadding*0.2;

        // Precompute desired lateral speed to drift ~ half-slot between rows
        const tRow = Math.max(0.14, Math.sqrt((2*STATE.rowGap)/STATE.g)); // ~time to fall one row
        const vHalfSlot = (GEO.colGap*0.5) / tRow;                         // px/s

        function frame(ts){
          if(!lastTs) lastTs=ts;
          const dt = Math.min(32, ts - lastTs) / 1000; // clamp to keep stable
          lastTs = ts;

          // Gravity
          vy += STATE.g * dt;

          // Integrate
          x += vx * dt;
          y += vy * dt;

          // Air drag (very subtle)
          vx *= (1 - airDrag);
          vy *= (1 - airDrag*0.5);

          // Walls
          if(x < leftBound){ x=leftBound; vx = Math.abs(vx)*0.6; }
          if(x > rightBound){ x=rightBound; vx = -Math.abs(vx)*0.6; }

          // Peg interaction per row (at row threshold)
          if(nextRow < GEO.N && y >= GEO.yRow(nextRow) - STATE.pegR*1.2){
            // compute step decision
            const rowsRemaining = GEO.N - nextRow;
            const step = decideStep(rights, rowsRemaining);
            if(step===1) rights++;

            // snap slightly toward real peg centre for visual contact
            const pegX = GEO.xPeg(nextRow, Math.min(rights, nextRow));
            x += (pegX - x) * 0.45;

            // bounce effect (reduce vy, add small pop)
            vy = Math.max(120, vy * 0.35);
            // lateral impulse toward chosen side + light randomness
            const jitter = (Math.random()-0.5) * (GEO.colGap*0.12);
            vx = step * vHalfSlot + jitter;

            nextRow++;
          }

          // Render
          ball.setAttribute('cx', x); ball.setAttribute('cy', y);

          // Landing
          if(y >= GEO.slotsY + 34){
            // Choose nearest slot
            let best=0,dist=Infinity;
            for(let s=0;s<=GEO.N;s++){
              const d=Math.abs(x - GEO.xSlot(s));
              if(d<dist){dist=d;best=s;}
            }
            // If guided, subtly snap outcome to target (visual consistency)
            const slotIndex = STATE.mode==='guided' ? STATE.targetSlot : best;

            // Animate settle
            ball.setAttribute('cx', GEO.xSlot(slotIndex)); ball.setAttribute('cy', GEO.slotsY + 34);

            const prize = Number(STATE.payouts[slotIndex]||0);
            session.drops++; session.winnings += prize;
            updateStats();
            highlightSlot(slotIndex);
            showToast(prize>0 ? `Win: ${fmtGBP(prize)} (Slot ${slotIndex})` : `No prize (Slot ${slotIndex})`);

            // fade
            let t0=null; function fade(t){ if(!t0)t0=t; const p=Math.min(1,(t-t0)/550); ball.setAttribute('opacity', String(0.97*(1-p))); if(p<1) requestAnimationFrame(fade); else svg.removeChild(ball); }
            requestAnimationFrame(fade);
            return; // stop loop
          }

          requestAnimationFrame(frame);
        }
        requestAnimationFrame(frame);
      } finally {
        // allow queue
        setTimeout(()=>{ dropping=false; if(queue>0){ queue--; drop(); } }, 60);
      }
    }

    function highlightSlot(idx, duration=640){
      const x=GEO.xSlot(idx), w=GEO.colGap*0.92;
      const g=document.createElementNS('http://www.w3.org/2000/svg','rect');
      g.setAttribute('x', x - w/2); g.setAttribute('y', GEO.slotsY);
      g.setAttribute('width', w); g.setAttribute('height', 50); g.setAttribute('rx','10');
      g.setAttribute('fill','none'); g.setAttribute('stroke','var(--gold)'); g.setAttribute('stroke-width','2.5'); g.setAttribute('opacity','0');
      svg.appendChild(g);
      let t0=null; function anim(t){ if(!t0)t0=t; const p=Math.min(1,(t-t0)/duration); g.setAttribute('opacity', String(0.9*(1-p))); if(p<1) requestAnimationFrame(anim); else svg.removeChild(g); }
      requestAnimationFrame(anim);
    }

    // ------- Wire UI -------
    drop1.addEventListener('click', ()=> drop());
    drop3.addEventListener('click', ()=> { drop(); drop(); drop(); });
    resetBtn.addEventListener('click', ()=>{
      session={drops:0,winnings:0}; updateStats(); buildBoard(); renderPayoutGrid(); updateSlotLabels(); updateMeta();
    });

    modeSel.addEventListener('change', ()=>{
      STATE.mode=modeSel.value;
      pRow.style.display = STATE.mode==='weighted' ? '' : 'none';
      targetRow.style.display = STATE.mode==='guided' ? '' : 'none';
      modeNote.textContent = STATE.mode==='guided'
        ? 'Guided: in production, the server picks the slot; client animation steers there.'
        : STATE.mode==='weighted'
          ? 'Weighted: per-peg right probability p; RTP reflects this.'
          : 'Unbiased: p=0.5; pure binomial.';
      updateMeta();
    });

    rowsInp.addEventListener('input', ()=>{
      STATE.rows = Math.max(6, Math.min(16, Number(rowsInp.value)|0));
      // resize payouts
      const newP = Array(STATE.rows+1).fill(0);
      for(let i=0;i<newP.length && i<STATE.payouts.length;i++) newP[i]=STATE.payouts[i];
      STATE.payouts = newP;
      buildBoard(); renderPayoutGrid(); renderPrizeForm(); updateSlotLabels(); updateMeta();
      targetInp.max = STATE.rows; targetInp.value = Math.min(STATE.rows, Number(targetInp.value)|0);
    });

    pInp.addEventListener('input', ()=>{ STATE.p = Number(pInp.value); updateMeta(); });
    targetInp.addEventListener('input', ()=>{ STATE.targetSlot = Math.max(0, Math.min(STATE.rows, Number(targetInp.value)|0)); });
    stakeInp.addEventListener('input', ()=>{ STATE.stake = Math.max(0.01, Number(stakeInp.value)||1); updateMeta(); });
    gravInp.addEventListener('input', ()=>{ STATE.g = Number(gravInp.value)||2600; });

    // ------- Init -------
    function init(){
      rowsInp.value = STATE.rows;
      pInp.value = STATE.p.toFixed(2);
      targetInp.value = STATE.targetSlot;
      stakeInp.value = STATE.stake.toFixed(2);
      gravInp.value = STATE.g;

      buildBoard(); renderPayoutGrid(); renderPrizeForm(); updateSlotLabels();
      modeSel.dispatchEvent(new Event('change'));
      updateMeta(); updateStats();
    }
    init();
  </script>
</body>
</html>
